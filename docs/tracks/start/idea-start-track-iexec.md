# Дополнительные идеи для интеграции iExec в DeepVest Crowdfunding

В дополнение к основному функционалу краудфандинга, платформа iExec может быть использована для автоматизированной и доверенной проверки выполнения некоторых этапов (мейлстоунов) стартапами. Это повышает прозрачность для инвесторов и снижает нагрузку на ручную модерацию.

## 1. Автоматизированная проверка выполнения технических задач через анализ GitHub-репозитория

**Концепция:** Стартап определяет технические цели для этапа, связанные с разработкой в GitHub. iExec запускает специальное приложение (App), которое анализирует репозиторий стартапа и предоставляет отчет о выполнении этих целей.

\*\*Варианты реализации (от простого к сложному):

### Вариант А: Проверка чеклиста в `README.md` (Упрощенный для MVP/Хакатона)

1.  **Определение целей:**
    - Стартап указывает технические цели этапа в DeepVest (например, "Реализован эндпоинт X", "Модуль Y покрыт тестами на Z%").
    - Эти же цели дублируются стартапом в `README.md` GitHub-репозитория в виде Markdown чеклиста (например, `- [ ] Цель 1`, `- [x] Цель 2`).
2.  \*\*iExec App (Docker-контейнер со скриптом):
    - **Входные данные:** URL GitHub-репозитория, опционально — список целей из DeepVest для сопоставления.
    - **Логика:**
      1.  Клонирует репозиторий.
      2.  Парсит `README.md`, находит секцию с чеклистом.
      3.  Проверяет, какие пункты отмечены как выполненные (`[x]`).
      4.  Формирует JSON-отчет с процентом выполнения и детализацией по каждой цели.
    - **Выходные данные:** JSON-отчет о выполнении.
3.  **Интеграция с DeepVest:**
    - При запросе на проверку этапа, DeepVest инициирует задачу в iExec.
    - Полученный JSON-отчет используется для информирования модератора или частичной автоматизации подтверждения этапа.

**Преимущества для MVP:** Относительная простота реализации скрипта (парсинг Markdown), наглядность демонстрации.

### Вариант Б: Базовый анализ кода и коммитов

1.  **Определение целей:** Более конкретные технические цели (например, "Наличие файла X", "Функция Y в файле Z", "Коммит с сообщением 'Fix #123'").
2.  \*\*iExec App:
    - **Входные данные:** URL репозитория, конкретный коммит/ветка, список критериев проверки.
    - **Логика:**
      1.  Клонирование репозитория.
      2.  Статический анализ: поиск файлов, функций, строк в коде (`grep`, простые парсеры).
      3.  Анализ истории коммитов.
    - **Выходные данные:** Отчет о соответствии критериям.

**Сложность:** Выше, чем вариант А, требует более сложных скриптов анализа.

### Вариант В: Продвинутый анализ (за рамками MVP)

1.  **Определение целей:** Комплексные цели (например, "Покрытие тестами модуля X не менее 80%", "Соответствие API спецификации OpenAPI Y", "Отсутствие уязвимостей класса Z по результатам сканера Snyk/SonarQube").
2.  \*\*iExec App:
    - **Логика:** Включает запуск тестовых фреймворков, инструментов статического анализа, сканеров безопасности внутри Docker-контейнера iExec.
    - **Выходные данные:** Детальный отчет с метриками.

**Сложность:** Значительно выше, требует подготовки сложных Docker-образов с необходимым инструментарием и обработки их вывода.

**Ценность GitHub-анализа через iExec:**

- **Объективность:** Внешняя, автоматизированная оценка прогресса.
- **Прозрачность:** Инвесторы могут видеть (в упрощенном виде) результаты проверки.
- **Экономия времени модераторов:** Снижение необходимости ручной проверки кода по некоторым аспектам.

## 2. Проверка доступности и корректности API эндпоинта (Health Check)

**Концепция:** Самый простой и быстрый способ продемонстрировать интеграцию с iExec. Стартап в рамках мейлстоуна обязуется развернуть сервис с определенным публичным API эндпоинтом (например, health check).

1.  **Определение цели в DeepVest:**
    - Стартап указывает: "Будет развернут сервис, доступный по URL `https://api.example.com/health`, который должен возвращать HTTP 200 и JSON `{"status": "ok"}`".
2.  \*\*iExec App (Docker-контейнер с простым скриптом):

    - **Входные данные:** URL целевого эндпоинта.
    - **Логика:**
      1.  Выполняет HTTP GET-запрос к URL.
      2.  Проверяет код ответа (ожидается 200).
      3.  Проверяет тело ответа (ожидается `{"status": "ok"}`).
    - **Выходные данные:** JSON-отчет, включающий URL, доступность, код ответа, фактическое тело ответа и результат сравнения с ожидаемым.
      ```json
      {
        "url_checked": "https://api.example.com/health",
        "is_reachable": true,
        "http_status_code": 200,
        "http_status_ok": true,
        "response_body_expected": "{\"status\": \"ok\"}",
        "response_body_actual": "{\"status\": \"ok\"}",
        "response_body_match": true
      }
      ```

    **Пример ультра-упрощенного shell-скрипта для iExec App:**

    ```bash
    #!/bin/sh
    # Входной параметр - URL (предполагается, что iExec передает его как первый аргумент)
    TARGET_URL=$1
    # Стандартная директория для выходных данных в iExec
    OUTPUT_DIR="/iexec_out"
    # Файл для результата
    RESULT_FILE="$OUTPUT_DIR/computed.json"

    # Ожидаемое тело ответа (для MVP можно захардкодить или передавать как параметр)
    EXPECTED_BODY='{"status": "ok"}'

    # Инициализация переменных для JSON отчета
    IS_REACHABLE="false"
    HTTP_STATUS_CODE=0
    HTTP_STATUS_OK="false"
    ACTUAL_BODY=""
    BODY_MATCH="false"

    # Выполнение запроса и сохранение кода ответа и тела
    # curl опции: -s (silent), -o (output to file), -w (write-out format)
    HTTP_STATUS_CODE=$(curl -s -o "$OUTPUT_DIR/response_body.tmp" -w "%{http_code}" "$TARGET_URL")

    if [ -f "$OUTPUT_DIR/response_body.tmp" ]; then
        ACTUAL_BODY=$(cat "$OUTPUT_DIR/response_body.tmp")
        # Удаляем временный файл после чтения
        rm "$OUTPUT_DIR/response_body.tmp"
    fi

    if [ "$HTTP_STATUS_CODE" -eq 200 ]; then
      IS_REACHABLE="true"
      HTTP_STATUS_OK="true"
      # Простое строковое сравнение для MVP
      if [ "$ACTUAL_BODY" = "$EXPECTED_BODY" ]; then
        BODY_MATCH="true"
      fi
    fi

    # Формирование JSON результата
    # Экранируем кавычки в ACTUAL_BODY для корректного JSON
    ESCAPED_ACTUAL_BODY=$(echo "$ACTUAL_BODY" | sed 's/"/\\"/g' | sed "s/'/\\'/g")
    ESCAPED_EXPECTED_BODY=$(echo "$EXPECTED_BODY" | sed 's/"/\\"/g' | sed "s/'/\\'/g")

    echo "{\"url_checked\": \"$TARGET_URL\", " > "$RESULT_FILE"
    echo "  \"is_reachable\": $IS_REACHABLE, " >> "$RESULT_FILE"
    echo "  \"http_status_code\": $HTTP_STATUS_CODE, " >> "$RESULT_FILE"
    echo "  \"http_status_ok\": $HTTP_STATUS_OK, " >> "$RESULT_FILE"
    echo "  \"response_body_expected\": \"$ESCAPED_EXPECTED_BODY\", " >> "$RESULT_FILE"
    echo "  \"response_body_actual\": \"$ESCAPED_ACTUAL_BODY\", " >> "$RESULT_FILE"
    echo "  \"response_body_match\": $BODY_MATCH" >> "$RESULT_FILE"
    echo "}" >> "$RESULT_FILE"

    # iExec ожидает файл computed.json в директории /iexec_out
    # Этот скрипт уже пишет результат в $RESULT_FILE, который и есть /iexec_out/computed.json
    ```

3.  **Интеграция с DeepVest:**
    - DeepVest инициирует задачу в iExec с указанным URL.
    - Результат используется для автоматического/полуавтоматического подтверждения части мейлстоуна.

**Преимущества для MVP/Хакатона:**

- **Минимальная сложность:** Скрипт может быть очень простым (curl, Python requests).
- **Быстрая реализация:** Легко создать Docker-образ и протестировать.
- **Наглядность:** Простой и понятный сценарий проверки.
- **Релевантность:** Доступность сервиса – фундаментальная проверка.

## 3. Другие потенциальные задачи для iExec в рамках инвест-проекта

- **Анализ Ончейн-Активности Стартапа:** Сбор и анализ данных о транзакциях, использовании смарт-контрактов стартапа, росте пользовательской базы токенов и т.д.
- **Обработка и Анализ Данных Пользовательской Активности:** Расчет DAU, MAU, Churn Rate, LTV по анонимизированным данным, предоставленным стартапом.
- **Нагрузочное Тестирование / Тестирование Производительности:** Запуск тестов (k6, JMeter) против API или демо-версии продукта стартапа.
- **Верификация AI/ML Моделей:** Запуск модели стартапа на тестовом датасете и оценка ее точности/производительности.
- **Проверка Конфигурации Инфраструктуры:** Анализ развертывания в облаке через CLI облачных провайдеров.
- **Анализ Финансовых Моделей/Прогнозов:** Запуск симуляций или проверка консистентности предоставленных стартапом моделей.
- **Верификация Контента Документации:** Проверка наличия, полноты, ключевых слов в технической или пользовательской документации.

При выборе задачи для iExec важно учитывать возможность ее полной автоматизации внутри контейнера, измеримость результата и доступность необходимых данных/окружения от стартапа.
